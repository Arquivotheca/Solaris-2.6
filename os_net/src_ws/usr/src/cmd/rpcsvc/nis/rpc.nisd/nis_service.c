#pragma ident	"@(#)nis_service.c	1.6	95/04/18 SMI"

/*
 *	nis_service.c
 *
 * This module contains the dispatch functions for the NIS+ service. At one
 * time it was generated by rpcgen, however, due to the requirement that it
 * be able to compile to a 4.1/sockets version or a 5.0/tli version and the
 * desire to collect statistics about the time spent in the service functions,
 * it is now "real" source. Changes to the .x file will have to be reconciled
 * with this file.
 */

#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
#include <syslog.h>
#include <signal.h>
#include <sys/types.h>
#include <memory.h>
#include <stropts.h>
#include <netconfig.h>
#include <sys/resource.h> /* rlimit */
#include <rpc/rpc.h>
#include <rpc/svc.h>
#include <rpcsvc/nis.h>
#include <rpcsvc/yp_prot.h>
#include "nis_proc.h"
#include "nis_svc.h"

typedef char *string_t;

extern int _rpcpmstart;		 /* Started by a port monitor ? */
extern int _rpcfdtype;		 /* Whether Stream or Datagram ? */
extern int _rpcsvcdirty;	 /* Still serving ? */

/*
 * NIS Version 2 (YP) Dispatch table
 */
extern int *ypproc_domain_svc();
extern int *ypproc_domain_nonack_svc();
extern struct ypresp_master *ypproc_master_svc();
extern struct ypresp_val *ypproc_match_svc();
extern struct ypresp_key_val *ypproc_first_svc();
extern struct ypresp_key_val *ypproc_next_svc();
extern struct ypresp_all *ypproc_all_svc();
extern struct ypresp_maplist *ypproc_maplist_svc();
extern bool xdr_ypresp_all();

void
ypprog_svc(rqstp, transp)
	struct svc_req *rqstp;
	register SVCXPRT *transp;
{
	union {
		string_t ypproc_domain_svc_arg;
		string_t ypproc_domain_nonack_svc_arg;
		struct ypreq_key ypproc_match_svc_arg;
		struct ypreq_nokey ypproc_first_svc_arg;
		struct ypreq_key ypproc_next_svc_arg;
		struct ypreq_nokey ypproc_all_svc_arg;
		struct ypreq_nokey ypproc_master_svc_arg;
		string_t ypproc_maplist_svc_arg;
	} argument;
	char *result;
	bool (*xdr_argument)(), (*xdr_result)();
	char *(*local)();

	_rpcsvcdirty = 1;
	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply(transp, xdr_void, (char *)NULL);
		_rpcsvcdirty = 0;
		return;

	case YPPROC_DOMAIN:
		xdr_argument = xdr_ypdomain_wrap_string;
		xdr_result = (bool (*)()) xdr_bool;
		local = (char *(*)()) ypproc_domain_svc;
		break;

	case YPPROC_DOMAIN_NONACK:
		xdr_argument = xdr_ypdomain_wrap_string;
		xdr_result = (bool (*)()) xdr_bool;
		local = (char *(*)()) ypproc_domain_nonack_svc;
		break;

	case YPPROC_MATCH:
		xdr_argument = xdr_ypreq_key;
		xdr_result = xdr_ypresp_val;
		local = (char *(*)()) ypproc_match_svc;
		break;

	case YPPROC_FIRST:
		xdr_argument = xdr_ypreq_nokey;
		xdr_result = xdr_ypresp_key_val;
		local = (char *(*)()) ypproc_first_svc;
		break;

	case YPPROC_NEXT:
		xdr_argument = xdr_ypreq_key;
		xdr_result = xdr_ypresp_key_val;
		local = (char *(*)()) ypproc_next_svc;
		break;

	case YPPROC_ALL:
		xdr_argument = xdr_ypreq_nokey;
		xdr_result = xdr_ypresp_all;
		local = (char *(*)()) ypproc_all_svc;
		break;

	case YPPROC_MASTER:
		xdr_argument = xdr_ypreq_nokey;
		xdr_result = xdr_ypresp_master;
		local = (char *(*)()) ypproc_master_svc;
		break;

	case YPPROC_MAPLIST:
		xdr_argument = xdr_ypdomain_wrap_string;
		xdr_result = xdr_ypresp_maplist;
		local = (char *(*)()) ypproc_maplist_svc;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvcdirty = 0;
		return;
	}
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, (xdrproc_t) xdr_argument,
							(char *) &argument)) {
		svcerr_decode(transp);
		_rpcsvcdirty = 0;
		return;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) xdr_result,
								result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, (xdrproc_t) xdr_argument,
							(char *) &argument)) {
		syslog(LOG_ERR, "yp_svc: unable to free arguments");
		exit(1);
	}
	_rpcsvcdirty = 0;
}

struct ops_stats nisopstats[24];

static void
start_stat(p)
	u_long	p;
{
	if ((p > 0) && (p < 24)) {
		nisopstats[p].calls++;
		__start_clock(7);
	}
}

static void
stop_stat(p, e)
	u_long  p;
	int	e;
{
	struct ops_stats	*os;
	u_long ndx;

	if ((p > 0) && (p < 24)) {
		os = &(nisopstats[p]);
		os->tsamps[os->cursamp] = __stop_clock(7);
		os->cursamp = (++(os->cursamp)%16);
		if (e)
			os->errors++;
	}
}

/*
 * NIS Version 3 (NIS+) dispatch function.
 */

void
nis_prog_svc(rqstp, transp)
	struct svc_req *rqstp;
	register SVCXPRT *transp;
{
	union {
		ns_request nis_lookup_svc_arg;
		ns_request nis_add_svc_arg;
		ns_request nis_modify_svc_arg;
		ns_request nis_remove_svc_arg;
		ib_request nis_iblist_svc_arg;
		ib_request nis_ibadd_svc_arg;
		ib_request nis_ibmodify_svc_arg;
		ib_request nis_ibremove_svc_arg;
		ib_request nis_ibfirst_svc_arg;
		ib_request nis_ibnext_svc_arg;
		fd_args nis_finddirectory_svc_arg;
		nis_taglist nis_status_svc_arg;
		dump_args nis_dumplog_svc_arg;
		dump_args nis_dump_svc_arg;
		netobj nis_callback_svc_arg;
		nis_name nis_cptime_svc_arg;
		nis_name nis_checkpoint_svc_arg;
		ping_args nis_ping_svc_arg;
		nis_taglist nis_servstate_svc_arg;
		nis_name nis_mkdir_svc_arg;
		nis_name nis_rmdir_svc_arg;
	} argument;
	char *result;
	bool_t (*xdr_argument)(), (*xdr_result)();
	char *(*local)();
	u_long	starttime;

	_rpcsvcdirty = 1;

	start_stat(rqstp->rq_proc);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply(transp, xdr_void, (char *)NULL);
		_rpcsvcdirty = 0;
		stop_stat(rqstp->rq_proc, 0);
		return;

	case NIS_LOOKUP:
		xdr_argument = xdr_ns_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_lookup_svc;
		break;

	case NIS_ADD:
		xdr_argument = xdr_ns_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_add_svc;
		break;

	case NIS_MODIFY:
		xdr_argument = xdr_ns_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_modify_svc;
		break;

	case NIS_REMOVE:
		xdr_argument = xdr_ns_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_remove_svc;
		break;

	case NIS_IBLIST:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_iblist_svc;
		break;

	case NIS_IBADD:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_ibadd_svc;
		break;

	case NIS_IBMODIFY:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_ibmodify_svc;
		break;

	case NIS_IBREMOVE:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_ibremove_svc;
		break;

	case NIS_IBFIRST:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_ibfirst_svc;
		break;

	case NIS_IBNEXT:
		xdr_argument = xdr_ib_request;
		xdr_result = xdr_nis_result;
		local = (char *(*)()) nis_ibnext_svc;
		break;

	case NIS_FINDDIRECTORY:
		xdr_argument = xdr_fd_args;
		xdr_result = xdr_fd_result;
		local = (char *(*)()) nis_finddirectory_svc;
		break;

	case NIS_STATUS:
		xdr_argument = xdr_nis_taglist;
		xdr_result = xdr_nis_taglist;
		local = (char *(*)()) nis_status_svc;
		break;

	case NIS_DUMPLOG:
		xdr_argument = xdr_dump_args;
		xdr_result = xdr_log_result;
		local = (char *(*)()) nis_dumplog_svc;
		break;

	case NIS_DUMP:
		xdr_argument = xdr_dump_args;
		xdr_result = xdr_log_result;
		local = (char *(*)()) nis_dump_svc;
		break;

	case NIS_CALLBACK:
		xdr_argument = xdr_netobj;
		xdr_result = xdr_bool;
		local = (char *(*)()) nis_callback_svc;
		break;

	case NIS_CPTIME:
		xdr_argument = xdr_nis_name;
		xdr_result = xdr_u_long;
		local = (char *(*)()) nis_cptime_svc;
		break;

	case NIS_CHECKPOINT:
		xdr_argument = xdr_nis_name;
		xdr_result = xdr_cp_result;
		local = (char *(*)()) nis_checkpoint_svc;
		break;

	case NIS_PING:
		xdr_argument = xdr_ping_args;
		xdr_result = xdr_void;
		local = (char *(*)()) nis_ping_svc;
		break;

	case NIS_SERVSTATE:
		xdr_argument = xdr_nis_taglist;
		xdr_result = xdr_nis_taglist;
		local = (char *(*)()) nis_servstate_svc;
		break;

	case NIS_MKDIR:
		xdr_argument = xdr_nis_name;
		xdr_result = xdr_nis_error;
		local = (char *(*)()) nis_mkdir_svc;
		break;

	case NIS_RMDIR:
		xdr_argument = xdr_nis_name;
		xdr_result = xdr_nis_error;
		local = (char *(*)()) nis_rmdir_svc;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvcdirty = 0;
		stop_stat(rqstp->rq_proc, 1);
		return;
	}
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, xdr_argument, (char *) &argument)) {
		svcerr_decode(transp);
		_rpcsvcdirty = 0;
		stop_stat(rqstp->rq_proc, 1);
		return;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (char *) &argument)) {
		syslog(LOG_ERR, "nis_svc: unable to free arguments");
		exit(1);
	}
	_rpcsvcdirty = 0;
	stop_stat(rqstp->rq_proc, 0);
}
