#ident	"@(#)kerbd_prot.c	1.4	93/05/26 SMI"
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <rpc/kerbd_prot.h>

/*
 *  RPC protocol information for kerbd, the usermode daemon which
 *  assists the kernel when handling kerberos ticket generation and
 *  validation.  It is kerbd which actually communicates with the
 *  kerberos KDC.
 *
 *  File generated from kerbd.x 1.2 91/05/01 SMI
 *
 *  Copyright 1990,1991 Sun Microsystems, Inc.
 */

bool_t
xdr_TICKET(XDR *xdrs, TICKET *objp)
{

	if (!xdr_bytes(xdrs, (char **)&objp->TICKET_val,
			(u_int *)&objp->TICKET_len, MAX_KTXT_LEN)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_KNAME(XDR *xdrs, KNAME *objp)
{

	if (!xdr_string(xdrs, objp, ANAME_SZ)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_KINST(XDR *xdrs, KINST *objp)
{

	if (!xdr_string(xdrs, objp, INST_SZ)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_KREALM(XDR *xdrs, KREALM *objp)
{

	if (!xdr_string(xdrs, objp, REALM_SZ)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ksetkcred_arg(XDR *xdrs, ksetkcred_arg *objp)
{

	if (!xdr_u_long(xdrs, &objp->cksum)) {
		return (FALSE);
	}
	if (!xdr_KNAME(xdrs, &objp->sname)) {
		return (FALSE);
	}
	if (!xdr_KINST(xdrs, &objp->sinst)) {
		return (FALSE);
	}
	if (!xdr_KREALM(xdrs, &objp->srealm)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ksetkcred_resd(XDR *xdrs, ksetkcred_resd *objp)
{

	if (!xdr_TICKET(xdrs, &objp->ticket)) {
		return (FALSE);
	}
	if (!xdr_des_block(xdrs, &objp->key)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ksetkcred_res(XDR *xdrs, ksetkcred_res *objp)
{

	if (!xdr_int(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case KSUCCESS:
		if (!xdr_ksetkcred_resd(xdrs, &objp->ksetkcred_res_u.res)) {
			return (FALSE);
		}
		break;
	}
	return (TRUE);
}

bool_t
xdr_kgetkcred_arg(XDR *xdrs, kgetkcred_arg *objp)
{

	if (!xdr_TICKET(xdrs, &objp->ticket)) {
		return (FALSE);
	}
	if (!xdr_KNAME(xdrs, &objp->sname)) {
		return (FALSE);
	}
	if (!xdr_KINST(xdrs, &objp->sinst)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->faddr)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_kgetkcred_resd(XDR *xdrs, kgetkcred_resd *objp)
{
	register long *buf;

	if (xdrs->x_op == XDR_ENCODE) {
		if (!xdr_KINST(xdrs, &objp->sinst)) {
			return (FALSE);
		}
		if (!xdr_u_int(xdrs, &objp->k_flags)) {
			return (FALSE);
		}
		if (!xdr_KNAME(xdrs, &objp->pname)) {
			return (FALSE);
		}
		if (!xdr_KINST(xdrs, &objp->pinst)) {
			return (FALSE);
		}
		if (!xdr_KREALM(xdrs, &objp->prealm)) {
			return (FALSE);
		}
		if (!xdr_u_long(xdrs, &objp->checksum)) {
			return (FALSE);
		}
		if (!xdr_des_block(xdrs, &objp->session)) {
			return (FALSE);
		}
		buf = XDR_INLINE(xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->life)) {
				return (FALSE);
			}
			if (!xdr_u_long(xdrs, &objp->time_sec)) {
				return (FALSE);
			}
			if (!xdr_u_long(xdrs, &objp->address)) {
				return (FALSE);
			}
		} else {
			IXDR_PUT_LONG(buf, objp->life);
			IXDR_PUT_U_LONG(buf, objp->time_sec);
			IXDR_PUT_U_LONG(buf, objp->address);
		}
		if (!xdr_TICKET(xdrs, &objp->reply)) {
			return (FALSE);
		}
		return (TRUE);
	}
	if (xdrs->x_op == XDR_DECODE) {
		if (!xdr_KINST(xdrs, &objp->sinst)) {
			return (FALSE);
		}
		if (!xdr_u_int(xdrs, &objp->k_flags)) {
			return (FALSE);
		}
		if (!xdr_KNAME(xdrs, &objp->pname)) {
			return (FALSE);
		}
		if (!xdr_KINST(xdrs, &objp->pinst)) {
			return (FALSE);
		}
		if (!xdr_KREALM(xdrs, &objp->prealm)) {
			return (FALSE);
		}
		if (!xdr_u_long(xdrs, &objp->checksum)) {
			return (FALSE);
		}
		if (!xdr_des_block(xdrs, &objp->session)) {
			return (FALSE);
		}
		buf = XDR_INLINE(xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->life)) {
				return (FALSE);
			}
			if (!xdr_u_long(xdrs, &objp->time_sec)) {
				return (FALSE);
			}
			if (!xdr_u_long(xdrs, &objp->address)) {
				return (FALSE);
			}
		} else {
			objp->life = IXDR_GET_LONG(buf);
			objp->time_sec = IXDR_GET_U_LONG(buf);
			objp->address = IXDR_GET_U_LONG(buf);
		}
		if (!xdr_TICKET(xdrs, &objp->reply)) {
			return (FALSE);
		}
		return (TRUE);
	}

	if (!xdr_KINST(xdrs, &objp->sinst)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->k_flags)) {
		return (FALSE);
	}
	if (!xdr_KNAME(xdrs, &objp->pname)) {
		return (FALSE);
	}
	if (!xdr_KINST(xdrs, &objp->pinst)) {
		return (FALSE);
	}
	if (!xdr_KREALM(xdrs, &objp->prealm)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->checksum)) {
		return (FALSE);
	}
	if (!xdr_des_block(xdrs, &objp->session)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->life)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->time_sec)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->address)) {
		return (FALSE);
	}
	if (!xdr_TICKET(xdrs, &objp->reply)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_kgetkcred_res(XDR *xdrs, kgetkcred_res *objp)
{

	if (!xdr_int(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case KSUCCESS:
		if (!xdr_kgetkcred_resd(xdrs, &objp->kgetkcred_res_u.res)) {
			return (FALSE);
		}
		break;
	}
	return (TRUE);
}

bool_t
xdr_kgetucred_arg(XDR *xdrs, kgetucred_arg *objp)
{

	if (!xdr_KNAME(xdrs, &objp->pname)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_kerb_ucred(XDR *xdrs, kerb_ucred *objp)
{

	if (!xdr_u_int(xdrs, &objp->uid)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->gid)) {
		return (FALSE);
	}
	if (!xdr_array(xdrs, (char **)&objp->grplist.grplist_val,
			(u_int *)&objp->grplist.grplist_len, KUCRED_MAXGRPS,
			sizeof (u_int), (xdrproc_t)xdr_u_int)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ucred_stat(XDR *xdrs, ucred_stat *objp)
{

	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_kgetucred_res(XDR *xdrs, kgetucred_res *objp)
{

	if (!xdr_ucred_stat(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case UCRED_OK:
		if (!xdr_kerb_ucred(xdrs, &objp->kgetucred_res_u.cred)) {
			return (FALSE);
		}
		break;
	case UCRED_UNKNOWN:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}
